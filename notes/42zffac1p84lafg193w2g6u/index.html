<!DOCTYPE html><html><head><meta charSet="utf-8"/><meta name="viewport" content="width=device-width"/><link rel="icon" href="/favicon.ico"/><title>Gem5学习</title><meta name="robots" content="index,follow"/><meta name="googlebot" content="index,follow"/><meta name="description" content="Personal Knowledge Space"/><meta property="og:title" content="Gem5学习"/><meta property="og:description" content="Personal Knowledge Space"/><meta property="og:url" content="https://Sherry-yanqi.github.io/Dendron-Website/./notes/42zffac1p84lafg193w2g6u/"/><meta property="og:type" content="article"/><meta property="article:published_time" content="9/22/2023"/><meta property="article:modified_time" content="10/10/2023"/><link rel="canonical" href="https://Sherry-yanqi.github.io/Dendron-Website/./notes/42zffac1p84lafg193w2g6u/"/><meta name="next-head-count" content="14"/><link rel="preload" href="/_next/static/css/8e7b7e4bce421c0a.css" as="style"/><link rel="stylesheet" href="/_next/static/css/8e7b7e4bce421c0a.css" data-n-g=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/_next/static/chunks/polyfills-c67a75d1b6f99dc8.js"></script><script src="/_next/static/chunks/webpack-3d209faeb64f2f97.js" defer=""></script><script src="/_next/static/chunks/framework-28c999baf2863c3d.js" defer=""></script><script src="/_next/static/chunks/main-104451f3d1a5c4bc.js" defer=""></script><script src="/_next/static/chunks/pages/_app-9d8e0603730b15a3.js" defer=""></script><script src="/_next/static/chunks/935-4dee79e80b8641c6.js" defer=""></script><script src="/_next/static/chunks/6-50972def09142ee2.js" defer=""></script><script src="/_next/static/chunks/pages/notes/%5Bid%5D-78d472fa3b924116.js" defer=""></script><script src="/_next/static/SHThAyINttQJV9i85PdhJ/_buildManifest.js" defer=""></script><script src="/_next/static/SHThAyINttQJV9i85PdhJ/_ssgManifest.js" defer=""></script></head><body><div id="__next" data-reactroot=""><section class="ant-layout" style="width:100%;min-height:100%"><header class="ant-layout-header" style="position:fixed;isolation:isolate;z-index:1;width:100%;border-bottom:1px solid #d4dadf;height:64px;padding:0 24px 0 2px"><div class="ant-row ant-row-center" style="max-width:992px;justify-content:space-between;margin:0 auto"><div style="display:flex" class="ant-col ant-col-xs-20 ant-col-sm-4"></div><div class="ant-col gutter-row ant-col-xs-0 ant-col-sm-20 ant-col-md-20 ant-col-lg-19"><div class="ant-select ant-select-lg ant-select-auto-complete ant-select-single ant-select-allow-clear ant-select-show-search" style="width:100%"><div class="ant-select-selector"><span class="ant-select-selection-search"><input type="search" autoComplete="off" class="ant-select-selection-search-input" role="combobox" aria-haspopup="listbox" aria-owns="undefined_list" aria-autocomplete="list" aria-controls="undefined_list" aria-activedescendant="undefined_list_0" value=""/></span><span class="ant-select-selection-placeholder">For full text search please use the &#x27;?&#x27; prefix. e.g. ? Onboarding</span></div></div></div><div style="display:none;align-items:center;justify-content:center" class="ant-col ant-col-xs-4 ant-col-sm-4 ant-col-md-0 ant-col-lg-0"><span role="img" aria-label="menu" style="font-size:24px" tabindex="-1" class="anticon anticon-menu"><svg viewBox="64 64 896 896" focusable="false" data-icon="menu" width="1em" height="1em" fill="currentColor" aria-hidden="true"><path d="M904 160H120c-4.4 0-8 3.6-8 8v64c0 4.4 3.6 8 8 8h784c4.4 0 8-3.6 8-8v-64c0-4.4-3.6-8-8-8zm0 624H120c-4.4 0-8 3.6-8 8v64c0 4.4 3.6 8 8 8h784c4.4 0 8-3.6 8-8v-64c0-4.4-3.6-8-8-8zm0-312H120c-4.4 0-8 3.6-8 8v64c0 4.4 3.6 8 8 8h784c4.4 0 8-3.6 8-8v-64c0-4.4-3.6-8-8-8z"></path></svg></span></div></div></header><section class="ant-layout" style="margin-top:64px;display:flex;flex-direction:row"><div class="site-layout-sidebar" style="flex:0 0 auto;width:calc(max((100% - 992px) / 2, 0px) + 200px);min-width:200px;padding-left:calc((100% - 992px) / 2)"><aside class="ant-layout-sider ant-layout-sider-dark" style="position:fixed;overflow:auto;height:calc(100vh - 64px);background-color:transparent;flex:0 0 200px;max-width:200px;min-width:200px;width:200px"><div class="ant-layout-sider-children"></div></aside></div><main class="ant-layout-content side-layout-main" style="max-width:1200px;min-width:0;display:block"><div style="padding:0 24px"><div class="main-content" role="main"><div class="ant-row"><div class="ant-col ant-col-24"><div class="ant-row" style="margin-left:-10px;margin-right:-10px"><div style="padding-left:10px;padding-right:10px" class="ant-col ant-col-xs-24 ant-col-md-18"><div><h1 id="gem5学习">Gem5学习<a aria-hidden="true" class="anchor-heading icon-link" href="#gem5学习"></a></h1>
<p>Shader,位置src/gpu-compute/shader.cc</p>
<h1 id="memory-system">Memory system<a aria-hidden="true" class="anchor-heading icon-link" href="#memory-system"></a></h1>
<h2 id="设计目标">设计目标<a aria-hidden="true" class="anchor-heading icon-link" href="#设计目标"></a></h2>
<p>Todo</p>
<h2 id="组件">组件<a aria-hidden="true" class="anchor-heading icon-link" href="#组件"></a></h2>
<p><a href="https://www.gem5.org/documentation/learning_gem5/part2/memoryobject/">reference website</a>
<a href="https://dingfen.github.io/cpp/2022/04/02/gem5-4.html#memory-system-modes">reference website</a></p>
<h3 id="ports">Ports<a aria-hidden="true" class="anchor-heading icon-link" href="#ports"></a></h3>
<p>在深入研究内存系统之前，我们应该首先理解 gem5 中的端口类 Port。因为所有在内存系统内的对象都要通过端口来建立连接，因而它们总是成对出现，这使得 gem5 的设计更加模块化。</p>
<h4 id="memory-system-modes">Memory system modes<a aria-hidden="true" class="anchor-heading icon-link" href="#memory-system-modes"></a></h4>
<ul>
<li>时序（timing）最重要的模式是时序模式。时序模式是产生正确仿真结果的唯一模式。其他模式仅在特殊情况下使用：</li>
<li>Atomic mode 原子模式常用于快进到感兴趣的模拟区域，以及预热缓存，这种模式假设在内存系统中不会产生任何事件。相反，所有的内存请求都通过一个长调用链执行。除非它将在快进或模拟器预热期间使用，否则不需要实现对内存对象的原子访问。</li>
<li>Functional mode 功能模式更适合描述为调试模式。功能模式用于从 host 读取数据到模拟器内存等操作。它在 Syscall Emulation(SE) 模式中被大量使用。例如，函数模式使用 process.cmd 从 host 中加载二进制文件，这样模拟系统就可以访问它。不论数据在何处，函数的读操作总能返回最新的数据，而其写操作中需要更新所有可能的有效数据（比如多个有效的缓存块中）。</li>
</ul>
<h4 id="port">Port<a aria-hidden="true" class="anchor-heading icon-link" href="#port"></a></h4>
<p>Port 类（端口）是 SimObject 之间的交互接口。在 gem5 中，Port 类是所有交互接口类（包括网络连接以及硬件模块端口连接等）的父类，其地位可见一斑。</p>
<pre class="language-c++"><code class="language-C++">class Port {
  private:
    const std::string portName;
    const PortID id;
    Port *_peer;
    bool _connected;
  protected:
	class UnboundPortException {};
  public:
    Port(const std::string&#x26; _name, PortID _id)
      : portName(_name), id(_id), _peer(nullptr), _connected(false)
};
</code></pre>
<ul>
<li>portName 是端口的描述名</li>
<li>id 类型为 typename int16_t PortID，用于在 vector 中区分并识别端口，当 id 为负数时，指示端口不在 vector 中。</li>
<li>_peer 指向与该端口相连的端口，</li>
<li>_connected 表示端口是否有一个端口与之相连。</li>
<li>空类 UnboundPortException，用于在程序发现未绑定端口时 throw 出特定的错误。
成对的两个端口如何进行绑定与解绑呢？很简单，只需要改变 _peer 指针就行：</li>
</ul>
<pre class="language-c++"><code class="language-C++">/** Attach to a peer port. */
virtual void bind(Port &#x26;peer) {
  _peer = &#x26;peer;
  _connected = true;
}

/** Dettach from a peer port. */
virtual void unbind() {
  _peer = nullptr;
  _connected = false;
}
</code></pre>
<p>takeOverFrom() 函数也提供了快速交换两个端口之间连接的方法。它将原本与 old 绑定的端口绑定。</p>
<pre class="language-c++"><code class="language-C++">void takeOverFrom(Port *old) {
  Port &#x26;peer = old->getPeer();
  // Disconnect the original binding.
  old->unbind();
  peer.unbind();
  // Connect the new binding.
  peer.bind(*this);
  bind(peer);
}
</code></pre>
<p>抽象内存对象（MemObject）
Gem5所有的内存对象都继承自MemObject，看过源码可以发现MemObject对象继承于ClockedObject对象，且仅添加了两个纯虚函数getMasterPort(const std::string &#x26;name)以及getSlavePort(const std::string &#x26;name)，这两个方法分别用来获得主从接口的名称。
端口（port）:
端口用来连接不同的内存对象，比如主端口（A类）连接从端口（B类），然后主端口（B类）连接从端口（C类）。主端口用来发送请求，与它连接的从端口接受请求，它们内部会有一对方法来实现请求的发送与接收。比如A类->sendTimingReq(pkt)以发送数据包，B类->recvTimingReq(pkt)接收。当然还有其他这样的方法对，比如（sendFunctional(Pkt)和recvFunctional(Pkt)）。每个内存对象至少拥有一个端口用于与整个系统连接。
连接端口
连接端口的过程是在Python脚本中配置的，通过类似A.port1 = B.port2的语句就可以将两个内存对象连接起来，需要注意的是Gem5对于例如总线这类可能拥有无限多对端口的对象会维护一个vector port来记录每一对连接到它上面的端口。对于vector port每一对新的连接会添加到vector的末尾，而一般的port会覆盖掉之前的连接。
端口代理：
一共有三种，其中PortProxy提供方法来写入和读取物理地址。它仅用于在模拟开始之前将数据加载到内存中并更新。SETranslatingPortProxy和FSTranslatingPortProxy提供与 PortProxy相同的方法，但传递给它们的地址是虚拟地址，并进行转换以获得物理地址。
数据包（packet）：
数据包用于封装内存系统中两个对象之间的传输，它一般包括以下数据</p>
<pre><code>    1.地址。这是将用于将数据包路由到其目标（如果未明确设置目的地）并在目标处处理数据包的地址。它通常源自请求对象的物理地址，但在某些情况下可能源自虚拟地址（例如，在执行地址转换之前访问完全虚拟缓存）。它可能与原始请求地址不同：例如，在缓存未命中时，数据包地址可能是要获取的块的地址，而不是请求地址。

   2.The size。大小可能与原始请求的大小不同，如缓存未命中情况。

   3.指向正在处理的数据的指针。由dataStatic()和dataDynamic()设置，它控制数据包释放时是否释放与数据包关联的数据。如果未通过上述方法之一设置，则分在数据包销毁时释放数据。可以通过调用getPtr()或getConstPtr()检索指针。get()和set()方法可用于操纵该数据包中的数据。get() 方法执行客机到主机的字节序转换，而 set 方法执行主机到客机的字节序转换。

   4.与数据包关联的命令属性列表。

   5.一个SenderState指针，它是一个虚拟基础不透明结构，用于保存与数据包关联的特定发送设备（例如，MSHR）的状态。在数据包的响应中返回指向此状态的指针，以便发送方可以快速查找处理它所需的状态。一个特定的子类将由此派生，以携带特定发送设备的状态。

   6.指向请求的指针。
</code></pre>
<p>请求对象封装了从CPU/IO发出的请求。请求对象的各个参数在事物的进行中保持不变，因此，对于给定的请求，请求对象的字段最多只能写入一次。有一些构造函数和更新方法允许在不同的时间写入对象字段的子集（或者根本不写入）。访问器方法提供对所有请求字段的读取访问，并验证正在读取的字段中的数据是否有效。</p>
<p>请求对象中的字段通常对实际系统中的设备不可用，因此它们通常仅用于统计或调试，而不是用作体系结构参数。</p>
<p>请求对象字段包括：</p>
<pre><code>    1.虚拟地址。如果请求直接在物理地址上发出（例如，由DMA I/O设备发出），则此字段可能无效。

    2.物理地址。

    3.数据大小。

    4.创建请求的时间。

    5.导致此请求的CPU/线程的ID。如果请求不是由CPU发出的（例如，设备访问或缓存写回），则可能无效。

    6.导致此请求的PC。如果请求不是由CPU发出的，也可能无效。
</code></pre>
<p>原子/时序/功能 三种访问：</p>
<p>一般端口都支持这三种访问方式</p>
<pre><code>    1.时序访问。时序访问是最详细的访问。它反应了最接近真实情况的建模方式，包括排队延迟和资源争用的建模。一旦在将来某个时间点成功发送时序请求，发送请求的设备将得到响应。定时和原子访问不能在内存系统中共存。这类似于TLM nb_传输接口。

    2.原子访问是一种更快的访问方式。它们用于快速转发和预热缓存，并返回完成请求的大致时间，而不会出现任何资源争用或排队延迟。当发送原子访问时，函数返回时将提供响应。原子访问和定时访问不能在内存系统中共存。这类似于TLM b_传输接口（无任何阻塞）。

    3.函数式原子访问函数式访问是瞬时发生的，但与原子访问不同，它们可以与原子访问或定时访问共存于内存系统中。函数访问用于加载二进制文件、检查/更改模拟系统中的变量，以及允许将远程调试器连接到模拟器。重要的注意事项是，当设备接收到功能访问时，如果它包含一个数据包队列，则必须搜索所有数据包，以查找功能访问正在影响的请求或响应，并且必须根据需要对其进行更新。Packet:：trySatisfyFunctional（）负责此操作。
</code></pre>
<p>时序流的控制</p>
<pre><code>    计时请求模拟真实的内存系统，因此与函数和原子访问不同，它们的响应不是瞬时的。因为定时请求不是瞬时的，所以需要流的控制。当通过sendTiming（）发送定时数据包时，数据包可能被接受，也可能不被接受，返回true或false。如果返回false，则对象在收到recvry（）调用之前不应尝试再发送数据包。此时，它应该再次尝试调用sendTiming（）；然而，分组可能再次被拒绝。注意：不需要重新发送原始数据包，可以发送更高优先级的数据包。
</code></pre>
<p>响应</p>
<pre><code>   内存系统中的范围是通过让所有从端口为GetAddRanges提供一个实现来处理的。此方法返回一个包含其响应地址的AddressRangeList。当这些范围发生变化时（例如，从PCI配置开始），设备应在其端口上调用sendRangeChange，以便将新范围传播到整个层次结构。这正是init（）期间发生的情况；所有内存对象都调用sendRangeChange（），并且会发生一连串的范围更新，直到每个人的范围都已传播到系统中的所有总线。
</code></pre>
<hr>
<strong>Backlinks</strong>
<ul>
<li><a href="/notes/0dedulbxl7totmeo56j36ao">Rocm</a></li>
</ul></div></div><div style="padding-left:10px;padding-right:10px" class="ant-col ant-col-xs-0 ant-col-md-6"><div><div class=""><div class="ant-anchor-wrapper dendron-toc" style="max-height:calc(100vh - 64px);z-index:1"><div class="ant-anchor"><div class="ant-anchor-ink"><span class="ant-anchor-ink-ball"></span></div><div class="ant-anchor-link"><a class="ant-anchor-link-title" href="#memory-system" title="Memory system">Memory system</a></div><div class="ant-anchor-link"><a class="ant-anchor-link-title" href="#设计目标" title="设计目标">设计目标</a></div><div class="ant-anchor-link"><a class="ant-anchor-link-title" href="#组件" title="组件">组件</a></div><div class="ant-anchor-link"><a class="ant-anchor-link-title" href="#ports" title="Ports">Ports</a></div><div class="ant-anchor-link"><a class="ant-anchor-link-title" href="#memory-system-modes" title="Memory system modes">Memory system modes</a></div><div class="ant-anchor-link"><a class="ant-anchor-link-title" href="#port" title="Port">Port</a></div></div></div></div></div></div></div></div></div></div></div><div class="ant-divider ant-divider-horizontal" role="separator"></div><footer class="ant-layout-footer" style="padding:0 24px 24px"></footer></main></section></section></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"note":{"id":"42zffac1p84lafg193w2g6u","title":"Gem5学习","desc":"","updated":1696904168539,"created":1695368027815,"custom":{},"fname":"tags.gem5学习","type":"note","vault":{"fsPath":".","selfContained":true,"name":"Dendron"},"contentHash":"69b923d71693f3375d67912f2a86d863","links":[{"from":{"fname":"rocm","id":"0dedulbxl7totmeo56j36ao","vaultName":"Dendron"},"type":"backlink","position":{"start":{"line":3,"column":1,"offset":14},"end":{"line":3,"column":8,"offset":21},"indent":[]},"value":"tags.gem5学习"}],"anchors":{"memory-system":{"type":"header","text":"Memory system","value":"memory-system","line":8,"column":0,"depth":1},"设计目标":{"type":"header","text":"设计目标","value":"设计目标","line":9,"column":0,"depth":2},"组件":{"type":"header","text":"组件","value":"组件","line":11,"column":0,"depth":2},"ports":{"type":"header","text":"Ports","value":"ports","line":14,"column":0,"depth":3},"memory-system-modes":{"type":"header","text":"Memory system modes","value":"memory-system-modes","line":16,"column":0,"depth":4},"port":{"type":"header","text":"Port","value":"port","line":20,"column":0,"depth":4}},"children":[],"parent":"90k77c0ismmit0y8v4lmv1e","data":{}},"body":"\u003ch1 id=\"gem5学习\"\u003eGem5学习\u003ca aria-hidden=\"true\" class=\"anchor-heading icon-link\" href=\"#gem5学习\"\u003e\u003c/a\u003e\u003c/h1\u003e\n\u003cp\u003eShader,位置src/gpu-compute/shader.cc\u003c/p\u003e\n\u003ch1 id=\"memory-system\"\u003eMemory system\u003ca aria-hidden=\"true\" class=\"anchor-heading icon-link\" href=\"#memory-system\"\u003e\u003c/a\u003e\u003c/h1\u003e\n\u003ch2 id=\"设计目标\"\u003e设计目标\u003ca aria-hidden=\"true\" class=\"anchor-heading icon-link\" href=\"#设计目标\"\u003e\u003c/a\u003e\u003c/h2\u003e\n\u003cp\u003eTodo\u003c/p\u003e\n\u003ch2 id=\"组件\"\u003e组件\u003ca aria-hidden=\"true\" class=\"anchor-heading icon-link\" href=\"#组件\"\u003e\u003c/a\u003e\u003c/h2\u003e\n\u003cp\u003e\u003ca href=\"https://www.gem5.org/documentation/learning_gem5/part2/memoryobject/\"\u003ereference website\u003c/a\u003e\n\u003ca href=\"https://dingfen.github.io/cpp/2022/04/02/gem5-4.html#memory-system-modes\"\u003ereference website\u003c/a\u003e\u003c/p\u003e\n\u003ch3 id=\"ports\"\u003ePorts\u003ca aria-hidden=\"true\" class=\"anchor-heading icon-link\" href=\"#ports\"\u003e\u003c/a\u003e\u003c/h3\u003e\n\u003cp\u003e在深入研究内存系统之前，我们应该首先理解 gem5 中的端口类 Port。因为所有在内存系统内的对象都要通过端口来建立连接，因而它们总是成对出现，这使得 gem5 的设计更加模块化。\u003c/p\u003e\n\u003ch4 id=\"memory-system-modes\"\u003eMemory system modes\u003ca aria-hidden=\"true\" class=\"anchor-heading icon-link\" href=\"#memory-system-modes\"\u003e\u003c/a\u003e\u003c/h4\u003e\n\u003cul\u003e\n\u003cli\u003e时序（timing）最重要的模式是时序模式。时序模式是产生正确仿真结果的唯一模式。其他模式仅在特殊情况下使用：\u003c/li\u003e\n\u003cli\u003eAtomic mode 原子模式常用于快进到感兴趣的模拟区域，以及预热缓存，这种模式假设在内存系统中不会产生任何事件。相反，所有的内存请求都通过一个长调用链执行。除非它将在快进或模拟器预热期间使用，否则不需要实现对内存对象的原子访问。\u003c/li\u003e\n\u003cli\u003eFunctional mode 功能模式更适合描述为调试模式。功能模式用于从 host 读取数据到模拟器内存等操作。它在 Syscall Emulation(SE) 模式中被大量使用。例如，函数模式使用 process.cmd 从 host 中加载二进制文件，这样模拟系统就可以访问它。不论数据在何处，函数的读操作总能返回最新的数据，而其写操作中需要更新所有可能的有效数据（比如多个有效的缓存块中）。\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch4 id=\"port\"\u003ePort\u003ca aria-hidden=\"true\" class=\"anchor-heading icon-link\" href=\"#port\"\u003e\u003c/a\u003e\u003c/h4\u003e\n\u003cp\u003ePort 类（端口）是 SimObject 之间的交互接口。在 gem5 中，Port 类是所有交互接口类（包括网络连接以及硬件模块端口连接等）的父类，其地位可见一斑。\u003c/p\u003e\n\u003cpre class=\"language-c++\"\u003e\u003ccode class=\"language-C++\"\u003eclass Port {\n  private:\n    const std::string portName;\n    const PortID id;\n    Port *_peer;\n    bool _connected;\n  protected:\n\tclass UnboundPortException {};\n  public:\n    Port(const std::string\u0026#x26; _name, PortID _id)\n      : portName(_name), id(_id), _peer(nullptr), _connected(false)\n};\n\u003c/code\u003e\u003c/pre\u003e\n\u003cul\u003e\n\u003cli\u003eportName 是端口的描述名\u003c/li\u003e\n\u003cli\u003eid 类型为 typename int16_t PortID，用于在 vector 中区分并识别端口，当 id 为负数时，指示端口不在 vector 中。\u003c/li\u003e\n\u003cli\u003e_peer 指向与该端口相连的端口，\u003c/li\u003e\n\u003cli\u003e_connected 表示端口是否有一个端口与之相连。\u003c/li\u003e\n\u003cli\u003e空类 UnboundPortException，用于在程序发现未绑定端口时 throw 出特定的错误。\n成对的两个端口如何进行绑定与解绑呢？很简单，只需要改变 _peer 指针就行：\u003c/li\u003e\n\u003c/ul\u003e\n\u003cpre class=\"language-c++\"\u003e\u003ccode class=\"language-C++\"\u003e/** Attach to a peer port. */\nvirtual void bind(Port \u0026#x26;peer) {\n  _peer = \u0026#x26;peer;\n  _connected = true;\n}\n\n/** Dettach from a peer port. */\nvirtual void unbind() {\n  _peer = nullptr;\n  _connected = false;\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003etakeOverFrom() 函数也提供了快速交换两个端口之间连接的方法。它将原本与 old 绑定的端口绑定。\u003c/p\u003e\n\u003cpre class=\"language-c++\"\u003e\u003ccode class=\"language-C++\"\u003evoid takeOverFrom(Port *old) {\n  Port \u0026#x26;peer = old-\u003egetPeer();\n  // Disconnect the original binding.\n  old-\u003eunbind();\n  peer.unbind();\n  // Connect the new binding.\n  peer.bind(*this);\n  bind(peer);\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e抽象内存对象（MemObject）\nGem5所有的内存对象都继承自MemObject，看过源码可以发现MemObject对象继承于ClockedObject对象，且仅添加了两个纯虚函数getMasterPort(const std::string \u0026#x26;name)以及getSlavePort(const std::string \u0026#x26;name)，这两个方法分别用来获得主从接口的名称。\n端口（port）:\n端口用来连接不同的内存对象，比如主端口（A类）连接从端口（B类），然后主端口（B类）连接从端口（C类）。主端口用来发送请求，与它连接的从端口接受请求，它们内部会有一对方法来实现请求的发送与接收。比如A类-\u003esendTimingReq(pkt)以发送数据包，B类-\u003erecvTimingReq(pkt)接收。当然还有其他这样的方法对，比如（sendFunctional(Pkt)和recvFunctional(Pkt)）。每个内存对象至少拥有一个端口用于与整个系统连接。\n连接端口\n连接端口的过程是在Python脚本中配置的，通过类似A.port1 = B.port2的语句就可以将两个内存对象连接起来，需要注意的是Gem5对于例如总线这类可能拥有无限多对端口的对象会维护一个vector port来记录每一对连接到它上面的端口。对于vector port每一对新的连接会添加到vector的末尾，而一般的port会覆盖掉之前的连接。\n端口代理：\n一共有三种，其中PortProxy提供方法来写入和读取物理地址。它仅用于在模拟开始之前将数据加载到内存中并更新。SETranslatingPortProxy和FSTranslatingPortProxy提供与 PortProxy相同的方法，但传递给它们的地址是虚拟地址，并进行转换以获得物理地址。\n数据包（packet）：\n数据包用于封装内存系统中两个对象之间的传输，它一般包括以下数据\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003e    1.地址。这是将用于将数据包路由到其目标（如果未明确设置目的地）并在目标处处理数据包的地址。它通常源自请求对象的物理地址，但在某些情况下可能源自虚拟地址（例如，在执行地址转换之前访问完全虚拟缓存）。它可能与原始请求地址不同：例如，在缓存未命中时，数据包地址可能是要获取的块的地址，而不是请求地址。\n\n   2.The size。大小可能与原始请求的大小不同，如缓存未命中情况。\n\n   3.指向正在处理的数据的指针。由dataStatic()和dataDynamic()设置，它控制数据包释放时是否释放与数据包关联的数据。如果未通过上述方法之一设置，则分在数据包销毁时释放数据。可以通过调用getPtr()或getConstPtr()检索指针。get()和set()方法可用于操纵该数据包中的数据。get() 方法执行客机到主机的字节序转换，而 set 方法执行主机到客机的字节序转换。\n\n   4.与数据包关联的命令属性列表。\n\n   5.一个SenderState指针，它是一个虚拟基础不透明结构，用于保存与数据包关联的特定发送设备（例如，MSHR）的状态。在数据包的响应中返回指向此状态的指针，以便发送方可以快速查找处理它所需的状态。一个特定的子类将由此派生，以携带特定发送设备的状态。\n\n   6.指向请求的指针。\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e请求对象封装了从CPU/IO发出的请求。请求对象的各个参数在事物的进行中保持不变，因此，对于给定的请求，请求对象的字段最多只能写入一次。有一些构造函数和更新方法允许在不同的时间写入对象字段的子集（或者根本不写入）。访问器方法提供对所有请求字段的读取访问，并验证正在读取的字段中的数据是否有效。\u003c/p\u003e\n\u003cp\u003e请求对象中的字段通常对实际系统中的设备不可用，因此它们通常仅用于统计或调试，而不是用作体系结构参数。\u003c/p\u003e\n\u003cp\u003e请求对象字段包括：\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003e    1.虚拟地址。如果请求直接在物理地址上发出（例如，由DMA I/O设备发出），则此字段可能无效。\n\n    2.物理地址。\n\n    3.数据大小。\n\n    4.创建请求的时间。\n\n    5.导致此请求的CPU/线程的ID。如果请求不是由CPU发出的（例如，设备访问或缓存写回），则可能无效。\n\n    6.导致此请求的PC。如果请求不是由CPU发出的，也可能无效。\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e原子/时序/功能 三种访问：\u003c/p\u003e\n\u003cp\u003e一般端口都支持这三种访问方式\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003e    1.时序访问。时序访问是最详细的访问。它反应了最接近真实情况的建模方式，包括排队延迟和资源争用的建模。一旦在将来某个时间点成功发送时序请求，发送请求的设备将得到响应。定时和原子访问不能在内存系统中共存。这类似于TLM nb_传输接口。\n\n    2.原子访问是一种更快的访问方式。它们用于快速转发和预热缓存，并返回完成请求的大致时间，而不会出现任何资源争用或排队延迟。当发送原子访问时，函数返回时将提供响应。原子访问和定时访问不能在内存系统中共存。这类似于TLM b_传输接口（无任何阻塞）。\n\n    3.函数式原子访问函数式访问是瞬时发生的，但与原子访问不同，它们可以与原子访问或定时访问共存于内存系统中。函数访问用于加载二进制文件、检查/更改模拟系统中的变量，以及允许将远程调试器连接到模拟器。重要的注意事项是，当设备接收到功能访问时，如果它包含一个数据包队列，则必须搜索所有数据包，以查找功能访问正在影响的请求或响应，并且必须根据需要对其进行更新。Packet:：trySatisfyFunctional（）负责此操作。\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e时序流的控制\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003e    计时请求模拟真实的内存系统，因此与函数和原子访问不同，它们的响应不是瞬时的。因为定时请求不是瞬时的，所以需要流的控制。当通过sendTiming（）发送定时数据包时，数据包可能被接受，也可能不被接受，返回true或false。如果返回false，则对象在收到recvry（）调用之前不应尝试再发送数据包。此时，它应该再次尝试调用sendTiming（）；然而，分组可能再次被拒绝。注意：不需要重新发送原始数据包，可以发送更高优先级的数据包。\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e响应\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003e   内存系统中的范围是通过让所有从端口为GetAddRanges提供一个实现来处理的。此方法返回一个包含其响应地址的AddressRangeList。当这些范围发生变化时（例如，从PCI配置开始），设备应在其端口上调用sendRangeChange，以便将新范围传播到整个层次结构。这正是init（）期间发生的情况；所有内存对象都调用sendRangeChange（），并且会发生一连串的范围更新，直到每个人的范围都已传播到系统中的所有总线。\n\u003c/code\u003e\u003c/pre\u003e\n\u003chr\u003e\n\u003cstrong\u003eBacklinks\u003c/strong\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ca href=\"/notes/0dedulbxl7totmeo56j36ao\"\u003eRocm\u003c/a\u003e\u003c/li\u003e\n\u003c/ul\u003e","noteIndex":{"id":"root","title":"root","desc":"","updated":1605266684036,"created":1595961348801,"custom":{"nav_order":0,"permalink":"/"},"fname":"root","type":"note","vault":{"fsPath":".","selfContained":true,"name":"Dendron"},"contentHash":"b49e7e13a0c91addc8ab9ef97080cf1e","links":[],"anchors":{},"children":["uxohjdz88o8hep8cr7hffz8","kl9mhirw795hadbnwlddcfi","0dedulbxl7totmeo56j36ao","c1bs7wsjfbhb0zipaywqv1","90k77c0ismmit0y8v4lmv1e"],"parent":null,"data":{},"body":"\nThis is the root for your Dendron vault.\n\nIf you decide to publish your entire vault, it will be your landing page. You are free to customize any part of this page except the frontmatter at the top, between the `---`.\n"},"collectionChildren":null,"customHeadContent":null,"config":{"version":5,"dev":{"enablePreviewV2":true,"enableSelfContainedVaults":true},"commands":{"lookup":{"note":{"selectionMode":"extract","confirmVaultOnCreate":true,"vaultSelectionModeOnCreate":"smart","leaveTrace":false,"bubbleUpCreateNew":true,"fuzzThreshold":0.2}},"randomNote":{},"insertNoteLink":{"aliasMode":"none","enableMultiSelect":false},"insertNoteIndex":{"enableMarker":false},"copyNoteLink":{"aliasMode":"title"},"templateHierarchy":"template"},"workspace":{"vaults":[{"fsPath":".","selfContained":true,"name":"Dendron"}],"journal":{"dailyDomain":"daily","name":"journal","dateFormat":"y.MM.dd","addBehavior":"childOfDomain"},"scratch":{"name":"scratch","dateFormat":"y.MM.dd.HHmmss","addBehavior":"asOwnDomain"},"task":{"name":"task","dateFormat":"y.MM.dd","addBehavior":"asOwnDomain","statusSymbols":{"":" ","wip":"w","done":"x","assigned":"a","moved":"m","blocked":"b","delegated":"l","dropped":"d","pending":"y"},"taskCompleteStatus":["done","x"],"prioritySymbols":{"H":"high","M":"medium","L":"low"},"todoIntegration":false,"createTaskSelectionType":"selection2link"},"graph":{"zoomSpeed":1,"createStub":false},"enableAutoCreateOnDefinition":false,"enableXVaultWikiLink":false,"enableRemoteVaultInit":true,"enableUserTags":true,"enableHashTags":true,"workspaceVaultSyncMode":"noCommit","enableAutoFoldFrontmatter":false,"enableEditorDecorations":true,"maxPreviewsCached":10,"maxNoteLength":204800,"enableFullHierarchyNoteTitle":false,"enablePersistentHistory":false},"preview":{"enableFMTitle":true,"enableNoteTitleForLink":true,"enableFrontmatterTags":true,"enableHashesForFMTags":false,"enablePrettyRefs":true,"enableKatex":true,"automaticallyShowPreview":false},"publishing":{"enableFMTitle":true,"enableNoteTitleForLink":true,"enablePrettyRefs":true,"enableKatex":true,"copyAssets":true,"siteHierarchies":["root"],"writeStubs":false,"siteRootDir":"docs","seo":{"title":"Dendron","description":"Personal Knowledge Space"},"github":{"enableEditLink":true,"editLinkText":"Edit this page on GitHub","editBranch":"main","editViewMode":"tree"},"enableSiteLastModified":true,"enableFrontmatterTags":true,"enableHashesForFMTags":false,"enableRandomlyColoredTags":true,"enableTaskNotes":true,"enablePrettyLinks":true,"searchMode":"search","siteUrl":"https://Sherry-yanqi.github.io/Dendron-Website/.","siteFaviconPath":"favicon.ico","siteIndex":"root"}}},"__N_SSG":true},"page":"/notes/[id]","query":{"id":"42zffac1p84lafg193w2g6u"},"buildId":"SHThAyINttQJV9i85PdhJ","isFallback":false,"gsp":true,"scriptLoader":[]}</script></body></html>