{"keys":[{"path":["title"],"id":"title","weight":1,"src":"title","getFn":null},{"path":["body"],"id":"body","weight":1,"src":"body","getFn":null}],"records":[{"i":0,"$":{"0":{"v":"This page has not yet sprouted","n":0.408},"1":{"v":"[Dendron](https://dendron.so/) (the tool used to generate this site) lets authors selective publish content. You will see this page whenever you click on a link to an unpublished page\n\n![](https://foundation-prod-assetspublic53c57cce-8cpvgjldwysl.s3-us-west-2.amazonaws.com/assets/images/not-sprouted.png)","n":0.189}}},{"i":1,"$":{"0":{"v":"root","n":1},"1":{"v":"\nThis is the root for your Dendron vault.\n\nIf you decide to publish your entire vault, it will be your landing page. You are free to customize any part of this page except the frontmatter at the top, between the `---`.\n","n":0.158}}},{"i":2,"$":{"0":{"v":"Tags","n":1}}},{"i":3,"$":{"0":{"v":"编译器","n":1},"1":{"v":"# GCC #\nGCC（GNU Compiler Collection）是一套有GNU开发的编程语言编译器，以GPL及LGPL许可证所发行的自由软件。GCC原名为GNU C 语言编译器，它原本只能处理C语言，随着技术的发展，GCC很快地得到扩展，变得可以处理C++，之后可以处理的语言扩展到Fortran、Pascal、Objective-C、Java等。\n\n# LLVM架构 ##\n![](images/LLVM架构图.webp)\n* 不同的前端后端使用统一的中间代码LLVM Intermediate Representation (LLVM IR)\n* 如果需要支持一种新的编程语言，那么只需要实现一个新的前端\n* 如果需要支持一种新的硬件设备，那么只需要实现一个新的后端\n* 优化阶段是一个通用的阶段，它针对的是统一的LLVM IR，不论是支持新的编程语言，还是支持新的硬件设备，都不需要对优化阶段做修改\n* 相比之下，GCC的前端和后端没分得太开，前端后端耦合在了一起。所以GCC为了支持一门新的语言，或者为了支持一个新的目标平台，就 变得特别困难\n* LLVM现在被作为实现各种静态和运行时编译语言的通用基础结构(GCC家族、Java、.NET、Python、Ruby、Scheme、Haskell、D等)\n# 什么是Clang ##\nLLVM项目的一个子项目，基于LLVM架构的C/C++/Objective-C编译器前端。\n相比于GCC，Clang具有如下优点\n编译速度快:在某些平台上，Clang的编译速度显著的快过GCC(Debug模式下编译OC速度比GGC快3倍)\n占用内存小:Clang生成的AST所占用的内存是GCC的五分之一左右\n模块化设计:Clang采用基于库的模块化设计，易于 IDE 集成及其他用途的重用\n诊断信息可读性强:在编译过程中，Clang 创建并保留了大量详细的元数据 (metadata)，有利于调试和错误报告\n设计清晰简单，容易理解，易于扩展增强\n\n# Clang和LLVM ##\n![](images/Clang和LLVM.webp)\n\nLLVM整体架构，前端用的是clang，广义的LLVM是指整个LLVM架构，一般狭义的LLVM指的是LLVM后端（包含代码优化和目标代码生成）。\n\n源代码（c/c++）经过clang--> 中间代码(经过一系列的优化，优化用的是Pass) --> 机器码\nCLang是一个由C++编写的编译器前端，能够编译C/C++/Objective等高级语言，属于LLVM的一部分，发布于BSD（自由软件中使用最广发的许可证之一）许可证下，其目的就是为了超越GCC。经过测试证明，Clang编译Objective-C代码的速度为GCC的3倍左右，同时它还能针对用户发生的编译错误准确地给出建议。\n\n# Clang和GCC的区别 #\n\n* Clang比GCC编译用的时间更短，包括预处理、语法分析、解析、语义分析、抽象语法树生成的时间。\n* Clang比GCC的内存占用更小。\n* Clang生成的中间产物比GCC更小。\n* Clang的错误提示比GCC更加友好。\n* Clang有静态分析，GCC没有。\n* Clang使用BSD许可证，GCC使用GPL许可证。\n* Clang从一开始就被设计为一个API，允许它被源代码分析工具和IDE集成。GCC被构建成一个单一的静态编译器，这使得它非常难以被作为API并集成到其他工具中。\n* GCC比Clang支持更多的语言，例如Java。\n* GCC比Clang支持更多的平台。\n* GCC比Clang更流行。\n","n":0.151}}},{"i":4,"$":{"0":{"v":"工作说明","n":1},"1":{"v":"\n## 环境\n## 目标\n- 搭一个rockml的环境，运行pytorch模型\n- 在5.5服务器上运行gem5+rocm\n    - 搭建好http代理环境以及github下载环境\n    - 编译gem5\n    - 编译\n        1. Heterogeneous Compute Compiler (HCC)\n        1. Radeon Open Compute runtime (ROCr)\n        1. Radeon Open Compute thunk (ROCt)\n        1. HIP\n    - 运行HIP_EXAMPLE 中的hello world\n## 安装\n### 注意\n* GCN3只能工作在system-call emulation (SE) mode，In particular, the emulated GPU driver supports the necessary ioctl() commands it receives from the userspace code. The source for the emulated GPU driver can be found in:\n    - The GPU compute driver: src/gpu-compute/gpu_compute_driver.[hh|cc]\n    - The HSA device driver: src/dev/hsa/hsa_driver.[hh|cc]\n* The HSA driver code models the basic functionality for an HSA agent, which is any device that can be targeted by the HSA runtime and accepts Architected Query Language (AQL) packets. AQL packets are a standard format for all HSA agents, and are used primarily to initiate kernel launches on the GPU. The base HSADriver class holds a pointer to the HSA packet processor for the device, and defines the interface for any HSA device. An HSA agent does not have to be a GPU, it could be a generic accelerator, CPU, NIC, etc.\n    The GPUComputeDriver derives from HSADriver and is a device-specific implementation of an HSADriver. It provides the implementation for GPU-specific ioctl() calls.\n\n    The src/dev/hsa/kfd_ioctl.h header must match the kfd_ioctl.h header that comes with ROCt. The emulated driver relies on that file to interpret the ioctl() codes the thunk uses.\n### 安装选择\n* **在用户目录下安装依赖项**\n    - zlib      v1.3.01 源码安装\n    - sqlit3(需要在python安装前安装， 在python的configure命令，一定要添加-enable-loadable-sqlite-extensions，因为默认是不开启的)，v3.44.0 源码安装\n    - python3， v3.6.15  源码安装\n    configure 时别忘了--enable-shared\n    --prefix=$HOME/tools --enable-loadable-sqlite-extensions \n    - protobuf  v3.5.0  系统自带\n    - m4        v1.4.18  源码安装\n    - scons     v4.0.0  pip3安装，其他版本报错\n    - openmpi   v4.1.5 源码安装（boost的图形库需要，故安装）\n    - boost     v1.83.0    源码安装\n    - gem5 v23.0.1.0\n  \n* ** 选择ROCm version 4.0.0 **\n    - Heterogeneous Compute Compiler (HCC)\n    - Radeon Open Compute runtime (ROCr)\n    - Radeon Open Compute thunk (ROCt)\n    - HIP\n* pytorch v1.8.0\n    - pip install torch -f https://download.pytorch.org/whl/rocm4.0.1/torch_stable.html\n    - pip install ninja\n    - pip install 'git+https://github.com/pytorch/vision.git@v0.9.0'\n### 安装过程\n1. 安装所需依赖\n2. 安装所需要的python第三方包，gem5根目录下有requirement.txt\n3. gem5编译，编译（各个依赖版本）\n4. 安装[MESA](mesahttps://github.com/Mesa3D/mesa.git)\n    - 依赖macros:\n        ```\n        //注意把安装位置，设置一下环境变量\n        export ACLOCAL_PATH=$HOME/tools/share/aclocal\n         ```\n  \n    - https://gitlab.freedesktop.org/xorg/lib/libxshmfence/-/tree/master?ref_type=heads\n    - pip install Mako\n5. 安装llvm(git clone -b rocm-4.0.0 https://github.com/RadeonOpenCompute/llvm-project.git)\n6. \n安装HIP（注意安装hip依赖，mesa-common-dev，clang，comgr，rocm-dkms）\n7. 下载hip-example，并调用其中的helloworld程序\n    运行命令\n```shell\nbuild/GCN3_X86/gem5.opt configs/example/apu_se.py -n 3 -c ~/rocm-4.0.0/HIP-Examples/HIP-Examples-Applications/HelloWorld/HelloWorld\n```\n执行Hello world过程报错\n* hip程序找不到libamd_comgr动态库\n    原因是apu_se.py文件中重新设置了动态库路径，故不包含libamd_comgr动态库\n    修改apu_se.py\n```python\nenv = ['LD_LIBRARY_PATH=%s' % ':'.join([\n            os.getenv('ROCM_PATH','/opt/rocm')+'/lib',\n            os.getenv('HCC_HOME','/opt/rocm/hcc')+'/lib',\n            os.getenv('HSA_PATH','/opt/rocm/hsa')+'/lib',\n            os.getenv('HIP_PATH','/opt/rocm/hip')+'/lib',\n            os.getenv('ROCM_PATH','/opt/rocm')+'/libhsakmt/lib',\n            os.getenv('ROCM_PATH','/opt/rocm')+'/miopen/lib',\n            os.getenv('ROCM_PATH','/opt/rocm')+'/miopengemm/lib',\n            os.getenv('ROCM_PATH','/opt/rocm')+'/hipblas/lib',\n            os.getenv('ROCM_PATH','/opt/rocm')+'/rocblas/lib',\n            \"/usr/lib/x86_64-linux-gnu\",\n            \"/home/lixianrui/tools/lib64\"\n        ]),\n        'HOME=%s' % os.getenv('HOME','/'),\n        \"HSA_ENABLE_INTERRUPT=1\"]\n```\n* 报错，fatal: syscall getdents64 (#217) unimplemented.\n    解决[](https://gem5-review.googlesource.com/c/public/gem5/+/46242)\n    报错request to allocate mask for invalid number: Invalid argument\n    解决按照[](https://gem5-review.googlesource.com/c/public/gem5/+/46243) 实现sched_getaffinity 系统调用\n* fatal: system.cpu3.CUs0 does not have any port named gmTokenPort。本周已经解决，查找到原因是gmTokenPort系统调用未实现，查找gem5的提交记录，从新版中找到实现，修改代码调试程序中进行对程序进行跟踪，解决bug。\n    错误解决[](https://gem5-review.googlesource.com/c/public/gem5/+/35096)\n* request to allocate mask for invalid number: Invalid argument\n    实现了sched_getaffinity 系统调用\n    附带着学习了gdb使用，并用gdb工具跟踪gem5 debug程序。\n* panic: Tried to read unmapped address 0x8\n 首先查到这个错误是在/src/x86下，故是发生在了gem5里面\n```shell\n执行命令：build/GCN3_X86/gem5.opt configs/example/apu_se.py  -c ~/rocm-4.0.0/HIP-Examples-rocm-4.0.0/HIP-Examples-Applications/FloydWarshall/FloydWarshall\n报错\nwarn: ignoring syscall get_mempolicy(...)\npanic: Tried to read unmapped address 0x8.\nPC: 0x7ffff8013e08, Instr:   CALL_NEAR_M : ld   t1, DS:[rbx]\nMemory Usage: 5724524 KBytes\n执行命令：build/GCN3_X86/gem5.opt configs/example/apu_se.py  -c ~/rocm-4.0.0/HIP-Examples-rocm-4.0.0/HIP-Examples-Applications/HelloWorld/HelloWorld\n报错\nwarn: ignoring syscall get_mempolicy(...)\npanic: Tried to read unmapped address 0x8.\nPC: 0x7ffff8013e08, Instr:   CALL_NEAR_M : ld   t1, DS:[rbx]\n执行命令：\nbuild/GCN3_X86/gem5.opt configs/example/apu_se.py  -c ~/rocm-4.0.0/HIP-Examples-rocm-4.0.0/HIP-Examples-Applications/SimpleConvolution/SimpleConvolution\n报错\nwarn: ignoring syscall get_mempolicy(...)\npanic: Tried to read unmapped address 0x8.\nPC: 0x7ffff8013e08, Instr:   CALL_NEAR_M : ld   t1, DS:[rbx]\n执行命令$build/GCN3_X86/gem5.opt configs/example/apu_se.py  -c gem5-resources/src/gpu/square/bin/square\n报错：warn: ignoring syscall get_mempolicy(...)\ninfo: Increasing stack size by one page.\nwarn: instruction 'fcomi' unimplemented\npanic: Tried to read unmapped address 0x8.\nPC: 0x7ffff8013e08, Instr:   CALL_NEAR_M : ld   t1, DS:[rbx]\nMemory Usage: 5741540 KBytes\n```\n根据warn: instruction 'fcomi' unimplemented查找有关提交，找到了[](https://gem5-review.googlesource.com/c/public/gem5/+/42443)关于fcomi的相关提交，用strance记录gem5调用记录，发现在最后gem5确实有调用libstdc++，报错指令CALL_NEAR_M : ld   t1, DS:[rbx]定义在./src/arch/x86/isa/insts/general_purpose/control_transfer/call.py。猜测或许有关，比较玄学，结果证明无关\n###资料列表\n[链接Documentation and Tutorials部分](https://www.gem5.org/documentation/general_docs/gpu_models/GCN3)\n[rocm仓库](http://repo.radeon.com/rocm/archive/)","n":0.044}}},{"i":5,"$":{"0":{"v":"Gem5学习","n":1},"1":{"v":"Shader,位置src/gpu-compute/shader.cc\n# Memory system #\n## 设计目标 ##\nTodo\n## 组件 ##\n[reference website](https://www.gem5.org/documentation/learning_gem5/part2/memoryobject/)\n[reference website](https://dingfen.github.io/cpp/2022/04/02/gem5-4.html#memory-system-modes)\n### Ports ###\n在深入研究内存系统之前，我们应该首先理解 gem5 中的端口类 Port。因为所有在内存系统内的对象都要通过端口来建立连接，因而它们总是成对出现，这使得 gem5 的设计更加模块化。\n#### Memory system modes ####\n* 时序（timing）最重要的模式是时序模式。时序模式是产生正确仿真结果的唯一模式。其他模式仅在特殊情况下使用：\n* Atomic mode 原子模式常用于快进到感兴趣的模拟区域，以及预热缓存，这种模式假设在内存系统中不会产生任何事件。相反，所有的内存请求都通过一个长调用链执行。除非它将在快进或模拟器预热期间使用，否则不需要实现对内存对象的原子访问。\n* Functional mode 功能模式更适合描述为调试模式。功能模式用于从 host 读取数据到模拟器内存等操作。它在 Syscall Emulation(SE) 模式中被大量使用。例如，函数模式使用 process.cmd 从 host 中加载二进制文件，这样模拟系统就可以访问它。不论数据在何处，函数的读操作总能返回最新的数据，而其写操作中需要更新所有可能的有效数据（比如多个有效的缓存块中）。\n#### Port #####\nPort 类（端口）是 SimObject 之间的交互接口。在 gem5 中，Port 类是所有交互接口类（包括网络连接以及硬件模块端口连接等）的父类，其地位可见一斑。\n``` C++\nclass Port {\n  private:\n    const std::string portName;\n    const PortID id;\n    Port *_peer;\n    bool _connected;\n  protected:\n\tclass UnboundPortException {};\n  public:\n    Port(const std::string& _name, PortID _id)\n      : portName(_name), id(_id), _peer(nullptr), _connected(false)\n};\n```\n* portName 是端口的描述名\n* id 类型为 typename int16_t PortID，用于在 vector 中区分并识别端口，当 id 为负数时，指示端口不在 vector 中。\n* _peer 指向与该端口相连的端口，\n* _connected 表示端口是否有一个端口与之相连。\n* 空类 UnboundPortException，用于在程序发现未绑定端口时 throw 出特定的错误。\n成对的两个端口如何进行绑定与解绑呢？很简单，只需要改变 _peer 指针就行：\n\n```C++\n/** Attach to a peer port. */\nvirtual void bind(Port &peer) {\n  _peer = &peer;\n  _connected = true;\n}\n\n/** Dettach from a peer port. */\nvirtual void unbind() {\n  _peer = nullptr;\n  _connected = false;\n}\n```\ntakeOverFrom() 函数也提供了快速交换两个端口之间连接的方法。它将原本与 old 绑定的端口绑定。\n```C++\nvoid takeOverFrom(Port *old) {\n  Port &peer = old->getPeer();\n  // Disconnect the original binding.\n  old->unbind();\n  peer.unbind();\n  // Connect the new binding.\n  peer.bind(*this);\n  bind(peer);\n}\n```\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n抽象内存对象（MemObject）\n    Gem5所有的内存对象都继承自MemObject，看过源码可以发现MemObject对象继承于ClockedObject对象，且仅添加了两个纯虚函数getMasterPort(const std::string &name)以及getSlavePort(const std::string &name)，这两个方法分别用来获得主从接口的名称。\n端口（port）:\n    端口用来连接不同的内存对象，比如主端口（A类）连接从端口（B类），然后主端口（B类）连接从端口（C类）。主端口用来发送请求，与它连接的从端口接受请求，它们内部会有一对方法来实现请求的发送与接收。比如A类->sendTimingReq(pkt)以发送数据包，B类->recvTimingReq(pkt)接收。当然还有其他这样的方法对，比如（sendFunctional(Pkt)和recvFunctional(Pkt)）。每个内存对象至少拥有一个端口用于与整个系统连接。\n连接端口\n       连接端口的过程是在Python脚本中配置的，通过类似A.port1 = B.port2的语句就可以将两个内存对象连接起来，需要注意的是Gem5对于例如总线这类可能拥有无限多对端口的对象会维护一个vector port来记录每一对连接到它上面的端口。对于vector port每一对新的连接会添加到vector的末尾，而一般的port会覆盖掉之前的连接。\n端口代理：\n       一共有三种，其中PortProxy提供方法来写入和读取物理地址。它仅用于在模拟开始之前将数据加载到内存中并更新。SETranslatingPortProxy和FSTranslatingPortProxy提供与 PortProxy相同的方法，但传递给它们的地址是虚拟地址，并进行转换以获得物理地址。\n数据包（packet）：\n数据包用于封装内存系统中两个对象之间的传输，它一般包括以下数据\n\n        1.地址。这是将用于将数据包路由到其目标（如果未明确设置目的地）并在目标处处理数据包的地址。它通常源自请求对象的物理地址，但在某些情况下可能源自虚拟地址（例如，在执行地址转换之前访问完全虚拟缓存）。它可能与原始请求地址不同：例如，在缓存未命中时，数据包地址可能是要获取的块的地址，而不是请求地址。\n\n       2.The size。大小可能与原始请求的大小不同，如缓存未命中情况。\n\n       3.指向正在处理的数据的指针。由dataStatic()和dataDynamic()设置，它控制数据包释放时是否释放与数据包关联的数据。如果未通过上述方法之一设置，则分在数据包销毁时释放数据。可以通过调用getPtr()或getConstPtr()检索指针。get()和set()方法可用于操纵该数据包中的数据。get() 方法执行客机到主机的字节序转换，而 set 方法执行主机到客机的字节序转换。\n\n       4.与数据包关联的命令属性列表。\n\n       5.一个SenderState指针，它是一个虚拟基础不透明结构，用于保存与数据包关联的特定发送设备（例如，MSHR）的状态。在数据包的响应中返回指向此状态的指针，以便发送方可以快速查找处理它所需的状态。一个特定的子类将由此派生，以携带特定发送设备的状态。\n\n       6.指向请求的指针。\n\n请求对象封装了从CPU/IO发出的请求。请求对象的各个参数在事物的进行中保持不变，因此，对于给定的请求，请求对象的字段最多只能写入一次。有一些构造函数和更新方法允许在不同的时间写入对象字段的子集（或者根本不写入）。访问器方法提供对所有请求字段的读取访问，并验证正在读取的字段中的数据是否有效。\n\n请求对象中的字段通常对实际系统中的设备不可用，因此它们通常仅用于统计或调试，而不是用作体系结构参数。\n\n请求对象字段包括：\n\n        1.虚拟地址。如果请求直接在物理地址上发出（例如，由DMA I/O设备发出），则此字段可能无效。\n\n        2.物理地址。\n\n        3.数据大小。\n\n        4.创建请求的时间。\n\n        5.导致此请求的CPU/线程的ID。如果请求不是由CPU发出的（例如，设备访问或缓存写回），则可能无效。\n\n        6.导致此请求的PC。如果请求不是由CPU发出的，也可能无效。\n\n原子/时序/功能 三种访问：\n\n一般端口都支持这三种访问方式\n\n        1.时序访问。时序访问是最详细的访问。它反应了最接近真实情况的建模方式，包括排队延迟和资源争用的建模。一旦在将来某个时间点成功发送时序请求，发送请求的设备将得到响应。定时和原子访问不能在内存系统中共存。这类似于TLM nb_传输接口。\n\n        2.原子访问是一种更快的访问方式。它们用于快速转发和预热缓存，并返回完成请求的大致时间，而不会出现任何资源争用或排队延迟。当发送原子访问时，函数返回时将提供响应。原子访问和定时访问不能在内存系统中共存。这类似于TLM b_传输接口（无任何阻塞）。\n\n        3.函数式原子访问函数式访问是瞬时发生的，但与原子访问不同，它们可以与原子访问或定时访问共存于内存系统中。函数访问用于加载二进制文件、检查/更改模拟系统中的变量，以及允许将远程调试器连接到模拟器。重要的注意事项是，当设备接收到功能访问时，如果它包含一个数据包队列，则必须搜索所有数据包，以查找功能访问正在影响的请求或响应，并且必须根据需要对其进行更新。Packet:：trySatisfyFunctional（）负责此操作。\n\n时序流的控制\n\n        计时请求模拟真实的内存系统，因此与函数和原子访问不同，它们的响应不是瞬时的。因为定时请求不是瞬时的，所以需要流的控制。当通过sendTiming（）发送定时数据包时，数据包可能被接受，也可能不被接受，返回true或false。如果返回false，则对象在收到recvry（）调用之前不应尝试再发送数据包。此时，它应该再次尝试调用sendTiming（）；然而，分组可能再次被拒绝。注意：不需要重新发送原始数据包，可以发送更高优先级的数据包。\n\n响应\n\n       内存系统中的范围是通过让所有从端口为GetAddRanges提供一个实现来处理的。此方法返回一个包含其响应地址的AddressRangeList。当这些范围发生变化时（例如，从PCI配置开始），设备应在其端口上调用sendRangeChange，以便将新范围传播到整个层次结构。这正是init（）期间发生的情况；所有内存对象都调用sendRangeChange（），并且会发生一连串的范围更新，直到每个人的范围都已传播到系统中的所有总线。\n","n":0.073}}},{"i":6,"$":{"0":{"v":"ROCm学习","n":1},"1":{"v":"# ROCm简介 #\nROCm(RadeonOpenCompute)是一个开源软件堆栈，主要由开源软件(OSS)组成，设计用于图形处理单元(GPU)计算。ROCm由一组驱动程序、开发工具和api组成，支持从低级内核到最终用户应用程序的GPU编程。使用ROCm，您可以自定义GPU软件以满足您的特定需求。您可以在免费、开源、集成和安全的软件生态系统中开发、协作、测试和部署您的应用程序。\n## 名词解释 ##\n### MIOpen ##\nAMD高性能机器学习原语库（AMD's library for high performance machine learning primitives），MIOpen支持两种编程模型HIP和OpenCL，对标cudann\n### HIP ###\nHIP：HIP是C++运行环境的API；一种kenerl语言，可用于编写可移植性程序，无关于硬件显卡种类\n### HSA ###\nHSA——Heterogeneous system architecture，可以简单理解为硬件上的一层抽象。 AMD 等为支持 CPU+GPU 混合计算生态而成立了非赢利组织 HSA 基金，提供 runtime 和架构 API 标准。现成员包括 AMD、三星、高通、ARM、TI、Imagination、MTK等。\n### GCN ###\nGCN——Graphics Core Next，是 AMD 11年推出的全新架构，以区别于之前基于基于 VLIW （超长指令字）的架构。由于现在所有 AMD GPU 都建于 GCN 架构，失去 ”next“ 的对象，因此，GCN 可以简单理解为 AMD GPU 架构\n### hip-clang ###\n在 ROCM v3.5 版本之前使用的编译器是 HCC，在之后的版本中被弃用，并且引入了 HIP-Clang 编译器来编译 HIP 程序。AMD 公司逐渐不去使用 HCC 编译器了，转而去研发 HIP 和 支持异构计算的其他语言，现在对于 HCC 不会再去发展新的特性了，也不会去维护了。\n* 编译HIP代码\n* hcc是clang的一种fork\n* It understands HIP and emits AMDGCN in the resulting\nbinary\n* hipcc -> hcc (clang) -> amdgcn\n* All the x86 pieces are dealt with in the same way\n### AOMP (AMD OpenMP Compiler) ### \n* Compiles C/C++ code with OpenMP “target” pragmas\n* Links with libomptarget to produce a binary that can offload work to the GPU\n### OpenCL ###\nKhronos Industry Standard accelerator language \n\n\n在实际应用中，GCN架构的AMD显卡通常符合HSA标准，这意味着它们能够更好地与其他HSA兼容的处理器（如AMD CPU）协同工作，共享内存和任务调度，从而提高整体性能。\n\n#编译器\nROCM相当于是HSA的一种实现\nGCN3是GPU的接口\n![](images/ROCM_STACK.png)\n# ROCm 和 CUDA对比 #\nA卡上编程模型使用的是HIP或者OpenCL，而运行环境是ROCm\nN卡上，编程模型是CUDA，运行环境也是CUDA\n![Alt text](image.png)\n![ROCm组件图](https://img-blog.csdnimg.cn/img_convert/c0467c6deeeba471e95614c8056c07c4.png)\n\n![ROCm和CUDA对比](images/ROCm和CUDA对比.png)\n![](https://img-blog.csdnimg.cn/565e5712981b461e8dda29a7c67687ca.png)\n![Alt text](image-1.png)\n[源码编译hip](https://rocm.docs.amd.com/projects/HIP/en/latest/developer_guide/build.html)\n![Important features include the following](https://img-blog.csdnimg.cn/d6a07744f4554ae68c85bbf0c27bb521.png)\n    rocFFT：快速傅里叶变换库，用于加速频域计算任务。\n    rocBLAS：基本线性代数子程序库，用于加速矩阵计算任务。\n    rocRAND：随机数生成库，用于生成随机数序列。\n    rocSPARSE：稀疏矩阵计算库，用于加速稀疏矩阵计算任务。","n":0.083}}},{"i":7,"$":{"0":{"v":"Tutorial","n":1},"1":{"v":"\nWelcome to Dendron! Dendron is a developer-focused knowledge base that helps you manage information using **flexible hierarchies**!\n\nYou are currently in the tutorial vault (a vault is the folder where your notes are stored). Feel free to edit this note and create new files as you go through the quickstart!\n\n## Create a Note\n\n1. Use `Ctrl+L` / `Cmd+L` to bring up the lookup prompt\n1. Type `dendron` and select `Create New`\n\n- > NOTE: After you press enter, Dendron will create and open the `dendron` note. Use `<CTRL>-<TAB>` to come back to this note\n\nYou just created your first note!\n\n- > NOTE: Notes in Dendron are just plain text markdown with some [frontmatter](https://wiki.dendron.so/notes/ffec2853-c0e0-4165-a368-339db12c8e4b) on the top. You can edit them in Dendron or using ~~vim~~ your favourite text editor.\n\n## Find a Note\n\n1. Use `Ctrl+L` / `Cmd+L` to bring up the lookup prompt again\n1. Type `dendron` and press `<ENTER>`\n\n- > TIP: you don't have to type out the entire query, press `<TAB>` to autocomplete\n\nYou just `looked up` a note!\n\n- > NOTE: in Dendron, you can find or create notes using the lookup prompt\n\n## Organize your Notes\n\n1. Bring up the lookup prompt again\n1. Type `tutorial.one`\n\nYou just created your first hierarchy!\n\n- > NOTE: hierarchies in Dendron are just `.` delimited files. This makes each note both a file and a folder and makes it easy to keep your notes organized\n\n- > TIP: You can use the [Dendron Tree View](https://wiki.dendron.so/notes/hur7r6gr3kqa56s2vme986j) to view your hierarchy. If it's not currently in focus, you can use `CTRL+SHIFT+P`/`CMD+SHIFT+P` to open the command prompt and type in `Dendron: focus on tree view` to make it appear\n\n## Create a link\n\n1. In the current note, type `[[` - this should trigger the autocomplete. You can type `one` to narrow it down to the note you just created and hit enter\n<!-- Enter '[[' below-->\n\n<!-- End space-->\n\nYou just created your first link!\n\n- > NOTE: the links with the `[[` are called wikilinks (because they were first popularized by Wikipedia)\n- > TIP: If you hover your mouse over the link, you can get a preview of the contents inside the note!\n\n## Navigate a link\n\n1. Move your text cursor over the link you just created. Hold down `<CTRL>+<ENTER>`/`<CMD>+<ENTER>`\n\n- > TIP: You can also use `CTRL+CLICK` or `CMD+CLICK` to navigate links via mouse\n\nYou just navigated the link!\n\n## Refactor a Note\n\n1. Open [[tutorial.one]], bring up the command prompt (`CTRL+SHIFT+P`/`CMD+SHIFT+P`) and type `Dendron: Rename Note`\n1. Replace `tutorial` with `my-note` and then press `<ENTER>`\n1. You just refactored the note!\n\n- > NOTE: when you rename a note, Dendron updates all links and references of the original note being renamed. Try switching back to [[tutorial]] to see the updated link!\n- > TIP: in addition to renaming one note at a time, dendron has [an entire collection](https://wiki.dendron.so/notes/srajljj10V2dl19nCSFiC) of refactoring commands that let you change headers, move around sections, and refactor entire hierarchies!\n\n## Conclusion\n\nCongrats, you finished the Dendron tutorial!\n\nWas there anything **unclear or buggy** about this tutorial? Please [**report it**](https://github.com/dendronhq/dendron/discussions/3266) so we can **make it better**!\n\n## Next Steps\n\nDepending on your needs, here are some common next steps:\n\n- I want to **start writing**: [Create a daily journal note](command:dendron.createDailyJournalNote) ([docs](https://wiki.dendron.so/notes/ogIUqY5VDCJP28G3cAJhd))\n\n- I want to **use templates**: Use the [Appy Template](https://wiki.dendron.so/notes/ftohqknticu6bw4cfmzskq6) command to apply [templates](https://wiki.dendron.so/notes/861cbdf8-102e-4633-9933-1f3d74df53d2) to existing notes\n\n- I want to do a **longer tutorial**: Check out our [5min tutorial to explore more of Dendron's functionality](https://wiki.dendron.so/notes/678c77d9-ef2c-4537-97b5-64556d6337f1/)\n\n- I want to **implement a particular workflow** (bullet journal, zettelkasten, etc): Check out community [workflow guides](https://wiki.dendron.so/notes/9313b845-d9bf-42c9-aad1-0da34794ce26)\n\n- I want to use Dendron for **tasks and todos**: See the [Getting Things Done (GTD), Bullet Journaling, and Other Task Management Workflows](https://wiki.dendron.so/notes/ordz7r99w1v099v14hrwgnp) for how the founder of Dendron uses it to manage his work.\n\n- I want to explore **advanced features**: See [next steps](https://wiki.dendron.so/notes/TflY5kn29HOLpp1pWT9tP) for longer walkthroughs and advanced functionality!\n\n- I want to start clean with a **new vault at a custom location**: Run [Dendron: Initialize Workspace](command:dendron.initWS) from the command prompt (or click this link) to start from a clean slate\n\n- I want to use Dendron as a **knowledge base for my team**: Read the [Dendron team setup](https://wiki.dendron.so/notes/98f6d928-3f61-49fb-9c9e-70c27d25f838) to get started\n\n> Coming from Obsidian? Click [here](command:dendron.importObsidianPod) to import your Obsidian notes (or any markdown notes) into Dendron to see how they look.\n\n## Community\n\nDendron is more that just a tool - we are also a community of individuals that are passionate about knowledge management. If you need help or want to connect with the community, join us in the [Discords](https://link.dendron.so/discord).\n\nYou can also:\n\n- Star us on [GitHub](https://github.com/dendronhq/dendron)\n- Follow us on [Twitter](https://twitter.com/dendronhq)\n- Subscribe to the [Dendron Newsletter](https://link.dendron.so/newsletter)\n","n":0.037}}},{"i":8,"$":{"0":{"v":"Rocm","n":1},"1":{"v":"#工作说明\n#ROCm学习\n#gem5学习\n\n\n","n":1}}},{"i":9,"$":{"0":{"v":"Gem5","n":1},"1":{"v":"ruby用于替换经典内存系统，ruby能够实现不同种类的一致性实现，是一个gem5中，内存组件\nruby组成，controller（由写一个SLICC状态机器文件实现）","n":1}}},{"i":10,"$":{"0":{"v":"CMAKE","n":1},"1":{"v":"#CMake\n[参考专栏](https://zhuanlan.zhihu.com/p/534439206)\n","n":1}}}]}
